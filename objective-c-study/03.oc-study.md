### 函数

- 定义函数

		
		函数返回值类型 函数名(形参列表) {
		
		
		}
		
		函数名  第一个单词首字母小写 后面的单词首字母大写
		
		形参列表  多参 用 , 分隔
		
		结束 return
		
		如果return实际返回数据类型 与 声明返回值类型不匹配
		
		就以返回值类型为准 并且将 return实际返回数据类型转为 声明的返回值类型
		
		如果没有return 返回明确的返回值 声明返回值类型最好是 void
		
		** C语言中不允许作嵌套的函数定义
		
	
	
- 函数声明

		
		1. 返回值类型 函数名 形成列表的形成类型 不保留形参
		
		2. 返回值类型 函数名 完成的形参列表 包括形参名
		
	
- 函数的参数传递机制

		
		只有一种机制  值传递
		
		所谓 值传递 就是将实际参数值的副本传入函数内 而参数本身不会受到影响
		
		值传递实质:
		
			当系统开始执行函数时 系统为形参执行初始化 就是把实参变量的值赋给函数的形参变量 函数里操作的并不是实际的实参变量
			
			对于指针类型的变量 Objective-c一样采用的值传递方式
			
			

- 函数递归

		
		一个函数体内调用它自身时候 被称之为 函数的递归
		

- 内部函数 / 外部函数

		
		函数本质是全局的
		
		根据 函数 是否可以被其他源文件所调用 分为 内部函数 和 外部函数
		
		
		内部函数  static 修饰  只能被当前源文件中所使用  具有更好内聚性
		
			可以保证函数只在该源文件中起作用 从而避免多个源文件中重名函数的冲突问题
		
		外部函数  extern 修饰  或者  不使用任何修饰符 可以被任何源文件中的函数
		
			1. 在使用的源文件上 需要声明 外部函数
			
			2.  需要 编译和链接 实现外部函数的源文件 一起
			
				clang -fobjc-arc -framework Foundation main.m externsource.m
				
				或
				
				在使用的文件 通过 #import "externsource.m"
				
					这种情况下 即便是static 也可以使用
					
		
	
- 局部变量 全局变量

		
		根据是否在函数内部
		
			如果在函数内部  就是  局部变量
			
			如果在函数外部  就是  全局变量
			
			
		局部变量根据定义形式的不同 分为 3种
		
			1. 形参
			
				作用域是在整个函数体内有效 
			
			2. 函数局部变量      
			
			3. 代码块局部变量
			
			
		全局变量
		
			如果在函数内部使用 后面 声明的全局变量
			
			就需要在函数内部 通过 extern 类型 全局变量名 这种方式 
			
			来声明全局变量 就可以使用后面声明的变量
			
			
		


- 外部全局变量 内部全局变量

		
		内部全局变量  static 修饰  限制在该源程序内部 其他源程序不能访问和修改
		
		外部全局变量  允许其他源程序访问和修改  但是其他源程序中 通过   extern  type 变量名
		
		注意 编译的时候 需要添加 定义外部全局的源程序
		
			如果通过 #import 定义外部全局变量的源程序
			
			就不需要编译添加
		
		


- 动态存储 静态存储

		
		从变量的存储机制角度 分为 动态存储 静态存储
		
		c程序运行的内存 分为 程序区 静态存储区  动态存储区
		
		变量 只会 静态存储区 和  动态存储区
		
		静态存储区变量 会在 程序运行开始时分配内存空间 直到程序运行结束才会释放内存
		
		静态存储区变量 分为两种
		
			1. 全局变量  
			
			2. static修饰局部变量
		
		动态存储区变量 是 动态分配的 生命周期结束会立刻收回内存
		
		动态存储区变量 分为 三种
		
			1. 函数形参变量
			
			2. 非static局部变量
			
			3. 函数执行的现场数据以及返回地址等
			
		
	

- 局部变量存储级别

		
		1. auto        局部变量的默认存储机制
		
		2. static  	   静态变量会存放到静态存储区
		
		3. register    变量存放到寄存器内
		
		4. extern      外部变量
		
		
		

- 预处理

		
		在编译器对程序进行编译之前 编译器程序进行编译之前 编译器会对这些预处理命令进行处理
		
		然后这些预处理的结果与源程序一起进行编译
		
		特征:
		
			1. 以#开头
			
			2. 位于程序开头
			
		


- #define #undef 宏的定义 结束宏

		
		#define 为字符串起一个名字
		
			#define YES 1
			
		宏名 所有字母大写的形式
		
		宏定义注意点 3
		
			1. 宏定义并不是c语句 不要宏名称与字符串之间使用 = 进行赋值  宏定义无须用分号;结束
			
			2. 宏定义并不是比变量 不是常量  不要对宏名称进行赋值
			
			3. 编译器处理宏定义只是进行 查找 替换
			
		宏定义的作用域从定义该宏开始 一直到该源码结束 如果提前结束宏定义
		
		#undef 宏名称
		
		
		


- 带参数的宏定义

		
		语法
		
			#define 宏名称(参数列表)  字符串
			
			#define AREA(R) PI * r * r
			
			调用
			
				AREA(5)
				
		建议将宏定义中的参数使用圆括号括起来 可以保证编译器先计算宏定义的参数
		
		如果整个宏定义返回的是数值 可以再将这个宏定义的字符串用圆括号括起来
		
		#define AREA(R) ( PI * (r) * (r) )
		
		

- #ifdef #ifndef #else #endif  执行条件编译

		
		#ifdef 宏名称
		
			语句
			
		#endif
		
		如果指定的宏名称定义了 就执行语句
		
		#ifdef 宏名称
		
			语句
			
		#else
		
			语句
			
		#endif
		
		
		#ifndef 宏名称
		
			语句
			
		#endif
		
		如果指定的宏名称没有定义 就执行语句
		
		#ifndef 宏名称
		
			语句
			
		#else
		
			语句
			
		#endif
		
		
		clang -fobjc-arc -framework Foundation -D DEBUG source.m...
		
		-D 选项 定义宏
		
		


- #if #elif #else #endif 执行条件编译


		
		#if    表达式
		
			语句
			
		#elif    表达式
		
			语句
			
			可以有另个 或 多个 #elif
			
			最后的#else也可以省略
			
		#else
		
			语句
			
		#endif
		
		
		
		


- #include #import

		
		c语言    #include 导入其他源程序
		
		
		oc      #import   导入其他源程序
		
		
		#include 就是讲指定的源码插入到当前源代码的指定位置
		
		#include 会重复导入 不会有提示
		
		
		#import  会自动判断重复导入位置的问题
		
		
		Objective-c 推荐 使用   #import 
		
		#import ""
		
		导入用户自定义的源程序使用 双引号来包含 源文件 #inport "source.h"
		
		这告诉预处理器将会到一个或多个路径下搜索指定的源文件  通常首先搜索当前文件所在路径
		
		但是可以通过Xcode设置预处理程序的搜索路径
		
		#import <>
		
		告诉系统只在特定的“系统”头文件路径中搜索被导入文件
		
		而不是在当前路径中搜索
		
		
		
		自己   #import  ""
		
		系统   #import  <>
		
		
		
		
		
		



### 指针

- 概念

		
		objective-c  系统类型的变量   自定义类型的变量 都是指针
		
		1. 通过变量来访问它的值
		
		2. 到该变量的存储位置去取它的值
		
		
		指针   本质是  内存地址
		
		


- 指针变量机器基本用法

		
		类型* 变量名;
		
		
		指针变量不能保存普通值 只能保存指针 就是内存地址
		
		
		1.   &     取地址运算符   单目     后面跟一个变量         用于读取变量的地址
		
		
		2.   *     取变量运算符   单目     后面跟一个指针变量     用于读取指针变量的所指变量
		
		
		*   和  &  两个运算符的优先级是相同的  是从右向左运算
		
		
		指针变量 本身 也是 变量 只是存储的是内存地址 
		
		变量 存储的是 普通值
		
		1. 定义指针变量时  必须用*来标识定义一个指针变量
		
		2. 所有的指针变量必须 先声明 后使用
		
		

- 指针变量作为函数参数

		
		函数的形参 不仅可以是 普通类型的变量 也可以是 指针类型的变量
		
		
		数组 本身 就是 指针
		
		


- 指针与数组

		
		数组中第一个元素的地址被称为 数组的首地址
		
		数组的首地址 会被当成 数组的地址
		
		C语言规定
		
			数组变量的本质 就是一个指针常量
			
			保存了指向第一个数组元素的指针
			
			简而言之
			
				数组变量 保存了 数组的首地址
				
				数组变量 是 指针常量  不能改变的 例如 不能重新赋值 
				
				
			int arr[] = {} ;
			
			int* p1 = &arr[0];
			
			int* p2 = arr;
		
			p1 与 p2  是相等
			
			


- 指针运算

		
		指针变量 加减一个整数  当指针变量 加 或 减 n 时候 代表将该指针的地址加 或 减 n * 变量大小个字节
		
		当两个指针变量指向同一个数组的元素时 两个指针变量可以相减 返回两个指针所指数组之间元素的个数
		
		当两个指针变量指向同一个数组的元素时 两个指针变量可以比较大小 前面 小于 后面
		
		
		总结
		
			假如arr是数组  arr+i 代表 第i+1元素的地址 arr+i === &a[i]
			
			假如arr是数组   *(arr+i) === a[i]
			
		

- 数组变量作为函数参数

		
		数组遍历作为参数 本质  就是讲指针变量作为参数
		
		
		
		


- 指向多维数组的指针变量

		
		多维数组 本质是 一维数组
		
		N维数组的本质是 其数组元素是N-1维数组的一维数组
		
		
		
		


- 字符串与指针

		
		c语言允许使用  字符指针 来表示 字符串
		
		char* str = "Hello world";
		
		字符串在底层依然采用是字符数组进行保存
		
		字符指针 实际上 指向 一个 字符数组
		
			char arr[] = "Hello world";
		
			char* str = arr;
		
		
		


- 字符指针作为参数

		
		c语言用字符指针 来指向 字符串
		
		当函数需要字符指针 作为 参数 可用 char* 声明形参
		
		
		字符数组 只能在 定义时候 赋值
		
		字符指针 可以 先声明 后赋值
		
		
		定义字符数组 会为没每个数组元素分配内存空间
		
		而声明 字符指针 只是一个指针变量 指向内存单元并没有确定
		
		


- 函数与指针


		
		指针可以执行函数
		
		1. 定义函数指针变量
		
			函数返回值类型 (* 指针变量名) ();
			
		2. 将已有的函数赋值给函数指针变量
		
			fnpt = avg;      // 使用隐含赋值
			
			fnpt = &avg;     // 使用 取地址 操作符
			
		3. 使用函数指针变量来调用函数
		
			(* fnpt)(参数)
			
		

- 用函数指针变量作为函数参数

		
		void map ( int* data, int len, int(*fn)() ) {
		
		}
		
		

- 返回指针的函数

		
		当函数返回指针时候需要 注意点
		
			由于函数返回的指针只保存了一个内地地址值
			
			如果该指针指向的是被调用函数中定义的局部变量
			
			是非常危险
			
			因为函数调用结束后 该函数中声明的局部变量所占用的空间已经释放了
			
			那么该指针指向的内存单元中存储的数据是不确定的
			
		措施：
		
			1. 如果函数的指针指向被调用函数中声明的局部变量 该局部变量应该使用static修饰
			
			2. 让函数返回的指针指向暂时不会被释放的数据 只有函数结束之前 指针是安全的
			
			
		
		
		

- 返回函数指针的函数

		
		指针函数  的本身是  一个  函数，其函数的返回值是一个指针
		
		函数指针  的本身是  一个  指针，指针指向的是一个函数
		
		
		1. 	指针函数的定义
		
			 类型名 *函数名(函数参数列表);
		
		
		2.	用函数指针作为函数的返回值
		
			 int (*ff (int) ) (int *, int);
		
		
		
		




- 指针数组 


		
		指针数组定义
		
			类型* 数组名[长度]
			
			char* strs[] = {"hello", "world"};
			
		注意
		
			类型（*变量名)[]
			
			这是 指向 一维数组的指针变量
			
			
		
		


- 指向指针变量的指针

		
		语法
		
			类型** 变量名
			
		int a = 100;
		
		int* b = &a;
		
		int** c = &b;
		
		

- 指针总结

		
		1. 数组 字符串  本质都是 内存地址
		
		
		
		
		



### 结构体

- 定义结构体

		
		struct 结构体名称 
		{
			// 成员列表
		
		}
		

- 定义结构体变量

		
		struct 结构体名 结构体变量名
		
		1. 使用#define 预编译指令struct ponit 定义一个简短的字符串
		
			#define PONINT struct ponit
			
		2. typeddef 为已有的结构体类型定义名称
		
			typeddef 已有名称  新名称
			
		

- 定义结构体并和结构体变量

		
		struct 结构体名称 
		{
			// 成员列表
		
		}变量1， 变量2;
		
		
		
		


- typedef

		
		为已有类型 定义 新名称
		
		typedef 已有类型 新名称;
		
		
		
		

- 初始化结构体变量

		
		结构体变量.成员名 = value
		
		结构体变量 = {...}
		
		


- 结构体数组

		
		struct 结构体名 结构体数组名[] = {...}
		


### 块

- 概述

		
		块 是 objective-c 对 ANSI C的扩展
		

- 语法

		
		^ [块返回值类型] (形参1, ....) {
			
			// 块执行体
		
		}
		
		






















